= ..sseelleecctt

(from gem actionpack-6.0.3.3)
=== IImmpplleemmeennttaattiioonn  ffrroomm  PPaarraammeetteerrss
------------------------------------------------------------------------
  select(&block)

------------------------------------------------------------------------

Returns a new instance of ActionController::Parameters with only items
that the block evaluates to true.


(from gem actionview-6.0.3.3)
=== IImmpplleemmeennttaattiioonn  ffrroomm  FFoorrmmBBuuiillddeerr
------------------------------------------------------------------------
  select(method, choices = nil, options = {}, html_options = {}, &block)

------------------------------------------------------------------------

Wraps ActionView::Helpers::FormOptionsHelper#select for form builders:

  <%= form_for @post do |f| %>
    <%= f.select :person_id, Person.all.collect { |p| [ p.name, p.id ] }, include_blank: true %>
    <%= f.submit %>
  <% end %>

Please refer to the documentation of the base helper for details.


(from gem actionview-6.0.3.3)
=== IImmpplleemmeennttaattiioonn  ffrroomm  FFoorrmmOOppttiioonnssHHeellppeerr
------------------------------------------------------------------------
  select(object, method, choices = nil, options = {}, html_options = {}, &block)

------------------------------------------------------------------------

Create a select tag and a series of contained option tags for the
provided object and method. The option currently held by the object will
be selected, provided that the object is available.

There are two possible formats for the choices parameter, corresponding
to other helpers' output:

* A flat collection (see options_for_select).

* A nested collection (see grouped_options_for_select).

For example:

  select("post", "person_id", Person.all.collect { |p| [ p.name, p.id ] }, { include_blank: true })

would become:

  <select name="post[person_id]" id="post_person_id">
    <option value=""></option>
    <option value="1" selected="selected">David</option>
    <option value="2">Eileen</option>
    <option value="3">Rafael</option>
  </select>

assuming the associated person has ID 1.

This can be used to provide a default set of options in the standard
way: before rendering the create form, a new model instance is assigned
the default options and bound to @model_name. Usually this model is not
saved to the database. Instead, a second model object is created when
the create request is received. This allows the user to submit a form
page more than once with the expected results of creating multiple
records. In addition, this allows a single partial to be used to
generate form inputs for both edit and create forms.

By default, post.person_id is the selected option. Specify selected:
value to use a different selection or selected: nil to leave all options
unselected. Similarly, you can specify values to be disabled in the
option tags by specifying the :disabled option. This can either be a
single value or an array of values to be disabled.

A block can be passed to select to customize how the options tags will
be rendered. This is useful when the options tag has complex attributes.

  select(report, "campaign_ids") do
    available_campaigns.each do |c|
      content_tag(:option, c.name, value: c.id, data: { tags: c.tags.to_json })
    end
  end

==== GGoottcchhaa

The HTML specification says when multiple parameter passed to select and
all options got deselected web browsers do not send any value to server.
Unfortunately this introduces a gotcha: if an User model has many roles
and have role_ids accessor, and in the form that edits roles of the user
the user deselects all roles from role_ids multiple select box, no
role_ids parameter is sent. So, any mass-assignment idiom like

  @user.update(params[:user])

wouldn't update roles.

To prevent this the helper generates an auxiliary hidden field before
every multiple select. The hidden field has the same name as multiple
select and blank value.

NNoottee:: The client either sends only the hidden field
(representing the deselected multiple select box), or both fields. This
means that the resulting array always contains a blank string.

In case if you don't want the helper to generate this hidden field you
can specify include_hidden: false option.


(from gem activerecord-6.0.3.3)
=== IImmpplleemmeennttaattiioonn  ffrroomm  CCoolllleeccttiioonnPPrrooxxyy
------------------------------------------------------------------------
  select(*fields, &block)

------------------------------------------------------------------------

Works in two ways.

FFiirrsstt:: Specify a subset of fields to be selected from the
result set.

  class Person < ActiveRecord::Base
    has_many :pets
  end

  person.pets
  # => [
  #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #    ]

  person.pets.select(:name)
  # => [
  #      #<Pet id: nil, name: "Fancy-Fancy">,
  #      #<Pet id: nil, name: "Spook">,
  #      #<Pet id: nil, name: "Choo-Choo">
  #    ]

  person.pets.select(:id, :name)
  # => [
  #      #<Pet id: 1, name: "Fancy-Fancy">,
  #      #<Pet id: 2, name: "Spook">,
  #      #<Pet id: 3, name: "Choo-Choo">
  #    ]

Be careful because this also means you're initializing a model object
with only the fields that you've selected. If you attempt to access a
field except id that is not in the initialized record you'll receive:

  person.pets.select(:name).first.person_id
  # => ActiveModel::MissingAttributeError: missing attribute: person_id

SSeeccoonndd:: You can pass a block so it can be used just like
Array#select. This builds an array of objects from the database for the
scope, converting them into an array and iterating through them using
Array#select.

  person.pets.select { |pet| pet.name =~ /oo/ }
  # => [
  #      #<Pet id: 2, name: "Spook", person_id: 1>,
  #      #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #    ]


(from gem activerecord-6.0.3.3)
=== IImmpplleemmeennttaattiioonn  ffrroomm  DDaattaabbaasseeSSttaatteemmeennttss
------------------------------------------------------------------------
  select(sql, name = nil, binds = [])

------------------------------------------------------------------------

Returns an ActiveRecord::Result instance.


(from gem activerecord-6.0.3.3)
=== IImmpplleemmeennttaattiioonn  ffrroomm  QQuueerryyMMeetthhooddss
------------------------------------------------------------------------
  select(*fields)

------------------------------------------------------------------------

Works in two unique ways.

First: takes a block so it can be used just like Array#select.

  Model.all.select { |m| m.field == value }

This will build an array of objects from the database for the scope,
converting them into an array and iterating through them using
Array#select.

Second: Modifies the SELECT statement for the query so that only certain
fields are retrieved:

  Model.select(:field)
  # => [#<Model id: nil, field: "value">]

Although in the above example it looks as though this method returns an
array, it actually returns a relation object and can have other query
methods appended to it, such as the other methods in
ActiveRecord::QueryMethods.

The argument to the method can also be an array of fields.

  Model.select(:field, :other_field, :and_one_more)
  # => [#<Model id: nil, field: "value", other_field: "value", and_one_more: "value">]

You can also use one or more strings, which will be used unchanged as
SELECT fields.

  Model.select('field AS field_one', 'other_field AS field_two')
  # => [#<Model id: nil, field: "value", other_field: "value">]

If an alias was specified, it will be accessible from the resulting
objects:

  Model.select('field AS field_one').first.field_one
  # => "value"

Accessing attributes of an object that do not have fields retrieved by a
select except id will throw ActiveModel::MissingAttributeError:

  Model.select(:field).first.other_field
  # => ActiveModel::MissingAttributeError: missing attribute: other_field


(from gem activesupport-6.0.3.3)
=== IImmpplleemmeennttaattiioonn  ffrroomm  HHaasshhWWiitthhIInnddiiffffeerreennttAAcccceessss
------------------------------------------------------------------------
  select(*args, &block)

------------------------------------------------------------------------


(from gem activesupport-6.0.3.3)
=== IImmpplleemmeennttaattiioonn  ffrroomm  OOrrddeerreeddHHaasshh
------------------------------------------------------------------------
  select(*args, &block)

------------------------------------------------------------------------


(from ruby core)
=== IImmpplleemmeennttaattiioonn  ffrroomm  AArrrraayy
------------------------------------------------------------------------
  ary.select {|item| block}   -> new_ary
  ary.select                  -> Enumerator

------------------------------------------------------------------------

Returns a new array containing all elements of ary for which the given
block returns a true value.

If no block is given, an Enumerator is returned instead.

  [1,2,3,4,5].select {|num| num.even? }     #=> [2, 4]

  a = %w[ a b c d e f ]
  a.select {|v| v =~ /[aeiou]/ }    #=> ["a", "e"]

See also Enumerable#select.

Array#filter is an alias for Array#select.


(from ruby core)
=== IImmpplleemmeennttaattiioonn  ffrroomm  GGeenneerriicc
------------------------------------------------------------------------
  select(*components)

------------------------------------------------------------------------

== AArrggss

components:
  Multiple Symbol arguments defined in Bundler::URI::HTTP.


== DDeessccrriippttiioonn

Selects specified components from Bundler::URI.

== UUssaaggee

  require 'bundler/vendor/uri/lib/uri'

  uri = Bundler::URI.parse('http://myuser:mypass@my.example.com/test.rbx')
  uri.select(:userinfo, :host, :path)
  # => ["myuser:mypass", "my.example.com", "/test.rbx"]


(from ruby core)
=== IImmpplleemmeennttaattiioonn  ffrroomm  DDBBMM
------------------------------------------------------------------------
  dbm.select {|key, value| block} -> array

------------------------------------------------------------------------

Returns a new array consisting of the [key, value] pairs for which the
code block returns true.


(from ruby core)
=== IImmpplleemmeennttaattiioonn  ffrroomm  EENNVV
------------------------------------------------------------------------
  ENV.select { |name, value| block } -> Hash
  ENV.select                         -> Enumerator

------------------------------------------------------------------------

Returns a copy of the environment for entries where the block returns
true.

Returns an Enumerator if no block was given.

ENV.filter is an alias for ENV.select.


(from ruby core)
=== IImmpplleemmeennttaattiioonn  ffrroomm  EEnnuummeerraabbllee
------------------------------------------------------------------------
  enum.select   { |obj| block } -> array
  enum.select                   -> an_enumerator

------------------------------------------------------------------------

Returns an array containing all elements of enum for which the given
block returns a true value.

The _f_i_n_d___a_l_l and _s_e_l_e_c_t methods are aliases.
There is no performance benefit to either.

If no block is given, an Enumerator is returned instead.

  (1..10).find_all { |i|  i % 3 == 0 }   #=> [3, 6, 9]

  [1,2,3,4,5].select { |num|  num.even?  }   #=> [2, 4]

  [:foo, :bar].filter { |x| x == :foo }   #=> [:foo]

See also Enumerable#reject, Enumerable#grep.


(from ruby core)
=== IImmpplleemmeennttaattiioonn  ffrroomm  LLaazzyy
------------------------------------------------------------------------
  lazy.select   { |obj| block } -> lazy_enumerator

------------------------------------------------------------------------

Like Enumerable#select, but chains operation to be lazy-evaluated.


(from ruby core)
=== IImmpplleemmeennttaattiioonn  ffrroomm  GGDDBBMM
------------------------------------------------------------------------
  gdbm.select { |key, value| block } -> array

------------------------------------------------------------------------

Returns a new array of all key-value pairs of the database for which
_b_l_o_c_k evaluates to true.


(from ruby core)
=== IImmpplleemmeennttaattiioonn  ffrroomm  HHaasshh
------------------------------------------------------------------------
  hsh.select {|key, value| block}   -> a_hash
  hsh.select                        -> an_enumerator

------------------------------------------------------------------------

Returns a new hash consisting of entries for which the block returns
true.

If no block is given, an enumerator is returned instead.

  h = { "a" => 100, "b" => 200, "c" => 300 }
  h.select {|k,v| k > "a"}  #=> {"b" => 200, "c" => 300}
  h.select {|k,v| v < 200}  #=> {"a" => 100}

Hash#filter is an alias for Hash#select.


(from ruby core)
=== IImmpplleemmeennttaattiioonn  ffrroomm  IIOO
------------------------------------------------------------------------
  IO.select(read_array [, write_array [, error_array [, timeout]]]) -> array or nil

------------------------------------------------------------------------

Calls select(2) system call. It monitors given arrays of IO objects,
waits until one or more of IO objects are ready for reading, are ready
for writing, and have pending exceptions respectively, and returns an
array that contains arrays of those IO objects.  It will return nil if
optional _t_i_m_e_o_u_t value is given and no IO object is ready
in _t_i_m_e_o_u_t seconds.

IO.select peeks the buffer of IO objects for testing readability. If the
IO buffer is not empty, IO.select immediately notifies readability. 
This "peek" only happens for IO objects.  It does not happen for IO-like
objects such as OpenSSL::SSL::SSLSocket.

The best way to use IO.select is invoking it after nonblocking methods
such as #read_nonblock, #write_nonblock, etc.  The methods raise an
exception which is extended by IO::WaitReadable or IO::WaitWritable. 
The modules notify how the caller should wait with IO.select.  If
IO::WaitReadable is raised, the caller should wait for reading.  If
IO::WaitWritable is raised, the caller should wait for writing.

So, blocking read (#readpartial) can be emulated using #read_nonblock
and IO.select as follows:

  begin
    result = io_like.read_nonblock(maxlen)
  rescue IO::WaitReadable
    IO.select([io_like])
    retry
  rescue IO::WaitWritable
    IO.select(nil, [io_like])
    retry
  end

Especially, the combination of nonblocking methods and IO.select is
preferred for IO like objects such as OpenSSL::SSL::SSLSocket.  It has
#to_io method to return underlying IO object.  IO.select calls #to_io to
obtain the file descriptor to wait.

This means that readability notified by IO.select doesn't mean
readability from OpenSSL::SSL::SSLSocket object.

The most likely situation is that OpenSSL::SSL::SSLSocket buffers some
data.  IO.select doesn't see the buffer.  So IO.select can block when
OpenSSL::SSL::SSLSocket#readpartial doesn't block.

However, several more complicated situations exist.

SSL is a protocol which is sequence of records. The record consists of
multiple bytes. So, the remote side of SSL sends a partial record,
IO.select notifies readability but OpenSSL::SSL::SSLSocket cannot
decrypt a byte and OpenSSL::SSL::SSLSocket#readpartial will block.

Also, the remote side can request SSL renegotiation which forces the
local SSL engine to write some data. This means
OpenSSL::SSL::SSLSocket#readpartial may invoke #write system call and it
can block. In such a situation, OpenSSL::SSL::SSLSocket#read_nonblock
raises IO::WaitWritable instead of blocking. So, the caller should wait
for ready for writability as above example.

The combination of nonblocking methods and IO.select is also useful for
streams such as tty, pipe socket socket when multiple processes read
from a stream.

Finally, Linux kernel developers don't guarantee that readability of
select(2) means readability of following read(2) even for a single
process. See select(2) manual on GNU/Linux system.

Invoking IO.select before IO#readpartial works well as usual. However it
is not the best way to use IO.select.

The writability notified by select(2) doesn't show how many bytes are
writable. IO#write method blocks until given whole string is written.
So, IO#write(two or more bytes) can block after writability is notified
by IO.select.  IO#write_nonblock is required to avoid the blocking.

Blocking write (#write) can be emulated using #write_nonblock and
IO.select as follows: IO::WaitReadable should also be rescued for SSL
renegotiation in OpenSSL::SSL::SSLSocket.

  while 0 < string.bytesize
    begin
      written = io_like.write_nonblock(string)
    rescue IO::WaitReadable
      IO.select([io_like])
      retry
    rescue IO::WaitWritable
      IO.select(nil, [io_like])
      retry
    end
    string = string.byteslice(written..-1)
  end

=== PPaarraammeetteerrss
read_array:
  an array of IO objects that wait until ready for read

write_array:
  an array of IO objects that wait until ready for write

error_array:
  an array of IO objects that wait for exceptions

timeout:
  a numeric value in second


=== EExxaammppllee

  rp, wp = IO.pipe
  mesg = "ping "
  100.times {
    # IO.select follows IO#read.  Not the best way to use IO.select.
    rs, ws, = IO.select([rp], [wp])
    if r = rs[0]
      ret = r.read(5)
      print ret
      case ret
      when /ping/
        mesg = "pong\n"
      when /pong/
        mesg = "ping "
      end
    end
    if w = ws[0]
      w.write(mesg)
    end
  }

_p_r_o_d_u_c_e_s_:

  ping pong
  ping pong
  ping pong
  (snipped)
  ping


(from ruby core)
=== IImmpplleemmeennttaattiioonn  ffrroomm  KKeerrnneell
------------------------------------------------------------------------
  IO.select(read_array [, write_array [, error_array [, timeout]]]) -> array or nil

------------------------------------------------------------------------

Calls select(2) system call. It monitors given arrays of IO objects,
waits until one or more of IO objects are ready for reading, are ready
for writing, and have pending exceptions respectively, and returns an
array that contains arrays of those IO objects.  It will return nil if
optional _t_i_m_e_o_u_t value is given and no IO object is ready
in _t_i_m_e_o_u_t seconds.

IO.select peeks the buffer of IO objects for testing readability. If the
IO buffer is not empty, IO.select immediately notifies readability. 
This "peek" only happens for IO objects.  It does not happen for IO-like
objects such as OpenSSL::SSL::SSLSocket.

The best way to use IO.select is invoking it after nonblocking methods
such as #read_nonblock, #write_nonblock, etc.  The methods raise an
exception which is extended by IO::WaitReadable or IO::WaitWritable. 
The modules notify how the caller should wait with IO.select.  If
IO::WaitReadable is raised, the caller should wait for reading.  If
IO::WaitWritable is raised, the caller should wait for writing.

So, blocking read (#readpartial) can be emulated using #read_nonblock
and IO.select as follows:

  begin
    result = io_like.read_nonblock(maxlen)
  rescue IO::WaitReadable
    IO.select([io_like])
    retry
  rescue IO::WaitWritable
    IO.select(nil, [io_like])
    retry
  end

Especially, the combination of nonblocking methods and IO.select is
preferred for IO like objects such as OpenSSL::SSL::SSLSocket.  It has
#to_io method to return underlying IO object.  IO.select calls #to_io to
obtain the file descriptor to wait.

This means that readability notified by IO.select doesn't mean
readability from OpenSSL::SSL::SSLSocket object.

The most likely situation is that OpenSSL::SSL::SSLSocket buffers some
data.  IO.select doesn't see the buffer.  So IO.select can block when
OpenSSL::SSL::SSLSocket#readpartial doesn't block.

However, several more complicated situations exist.

SSL is a protocol which is sequence of records. The record consists of
multiple bytes. So, the remote side of SSL sends a partial record,
IO.select notifies readability but OpenSSL::SSL::SSLSocket cannot
decrypt a byte and OpenSSL::SSL::SSLSocket#readpartial will block.

Also, the remote side can request SSL renegotiation which forces the
local SSL engine to write some data. This means
OpenSSL::SSL::SSLSocket#readpartial may invoke #write system call and it
can block. In such a situation, OpenSSL::SSL::SSLSocket#read_nonblock
raises IO::WaitWritable instead of blocking. So, the caller should wait
for ready for writability as above example.

The combination of nonblocking methods and IO.select is also useful for
streams such as tty, pipe socket socket when multiple processes read
from a stream.

Finally, Linux kernel developers don't guarantee that readability of
select(2) means readability of following read(2) even for a single
process. See select(2) manual on GNU/Linux system.

Invoking IO.select before IO#readpartial works well as usual. However it
is not the best way to use IO.select.

The writability notified by select(2) doesn't show how many bytes are
writable. IO#write method blocks until given whole string is written.
So, IO#write(two or more bytes) can block after writability is notified
by IO.select.  IO#write_nonblock is required to avoid the blocking.

Blocking write (#write) can be emulated using #write_nonblock and
IO.select as follows: IO::WaitReadable should also be rescued for SSL
renegotiation in OpenSSL::SSL::SSLSocket.

  while 0 < string.bytesize
    begin
      written = io_like.write_nonblock(string)
    rescue IO::WaitReadable
      IO.select([io_like])
      retry
    rescue IO::WaitWritable
      IO.select(nil, [io_like])
      retry
    end
    string = string.byteslice(written..-1)
  end

=== PPaarraammeetteerrss
read_array:
  an array of IO objects that wait until ready for read

write_array:
  an array of IO objects that wait until ready for write

error_array:
  an array of IO objects that wait for exceptions

timeout:
  a numeric value in second


=== EExxaammppllee

  rp, wp = IO.pipe
  mesg = "ping "
  100.times {
    # IO.select follows IO#read.  Not the best way to use IO.select.
    rs, ws, = IO.select([rp], [wp])
    if r = rs[0]
      ret = r.read(5)
      print ret
      case ret
      when /ping/
        mesg = "pong\n"
      when /pong/
        mesg = "ping "
      end
    end
    if w = ws[0]
      w.write(mesg)
    end
  }

_p_r_o_d_u_c_e_s_:

  ping pong
  ping pong
  ping pong
  (snipped)
  ping


(from ruby core)
=== IImmpplleemmeennttaattiioonn  ffrroomm  IIMMAAPP
------------------------------------------------------------------------
  select(mailbox)

------------------------------------------------------------------------

Sends a SELECT command to select a mailbox so that messages in the
mailbox can be accessed.

After you have selected a mailbox, you may retrieve the number of items
in that mailbox from @responses["EXISTS"][-1], and the number of recent
messages from @responses["RECENT"][-1]. Note that these values can
change if new messages arrive during a session; see
#add_response_handler() for a way of detecting this event.

A Net::IMAP::NoResponseError is raised if the mailbox does not exist or
is for some reason non-selectable.


(from ruby core)
=== IImmpplleemmeennttaattiioonn  ffrroomm  SSDDBBMM
------------------------------------------------------------------------
  sdbm.select { |key, value| ... } -> Array

------------------------------------------------------------------------

Returns a new Array of key-value pairs for which the block returns true.

Example:

  require 'sdbm'

  SDBM.open 'my_database' do |db|
    db['apple'] = 'fruit'
    db['pear'] = 'fruit'
    db['spinach'] = 'vegetable'

    veggies = db.select do |key, value|
      value == 'vegetable'
    end #=> [["apple", "fruit"], ["pear", "fruit"]]
  end


(from ruby core)
=== IImmpplleemmeennttaattiioonn  ffrroomm  SSttrruucctt
------------------------------------------------------------------------
  struct.select {|obj| block }  -> array
  struct.select                 -> enumerator

------------------------------------------------------------------------

Yields each member value from the struct to the block and returns an
Array containing the member values from the struct for which the given
block returns a true value (equivalent to Enumerable#select).

  Lots = Struct.new(:a, :b, :c, :d, :e, :f)
  l = Lots.new(11, 22, 33, 44, 55, 66)
  l.select {|v| v.even? }   #=> [22, 44, 66]

Struct#filter is an alias for Struct#select.


(from ruby core)
=== IImmpplleemmeennttaattiioonn  ffrroomm  GGeenneerriicc
------------------------------------------------------------------------
  select(*components)

------------------------------------------------------------------------

== AArrggss

components:
  Multiple Symbol arguments defined in URI::HTTP.


== DDeessccrriippttiioonn

Selects specified components from URI.

== UUssaaggee

  require 'uri'

  uri = URI.parse('http://myuser:mypass@my.example.com/test.rbx')
  uri.select(:userinfo, :host, :path)
  # => ["myuser:mypass", "my.example.com", "/test.rbx"]


(from ruby core)
=== IImmpplleemmeennttaattiioonn  ffrroomm  DDBBMM
------------------------------------------------------------------------
  ydbm.select { |key, value| ... }
  ydbm.select(*keys)

------------------------------------------------------------------------

If a block is provided, returns a new array containing [key, value]
pairs for which the block returns true.

Otherwise, same as #values_at


